<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有序数组的平方--首尾双指针+归并思想</title>
      <link href="/2021/10/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-%E9%A6%96%E5%B0%BE%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BD%92%E5%B9%B6%E6%80%9D%E6%83%B3/"/>
      <url>/2021/10/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-%E9%A6%96%E5%B0%BE%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BD%92%E5%B9%B6%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode-977.有序数组的平方"></a>LeetCode-977.有序数组的平方</h2><p><strong>给你一个按非递减顺序 排序的整数数组 nums，返回每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</strong></p><span id="more"></span><br>示例 1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><br>示例 2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 已按 非递减顺序 排序</span><br></pre></td></tr></table></figure>进阶：请你设计时间复杂度为 O(n) 的算法解决本问题<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">链接：977.有序数组的平方</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>　　题目既然给了有序的条件就要利用好，平方只是一个干扰。平方后数组递减后递增，呈“V”字形，使用首尾双指针比较元素后填数即可。本质上是两个有序子序列的重新排序，属于<strong>归并思想</strong>。官方题解的第二种方法还需要找出中间的分界值，感觉没这必要，从中间往两边扩散很容易数组越界==　　</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开辟新数组存储结果</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; newNums = <span class="built_in">vector</span>(nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//对两个递减和递增子序列排序，本质上是归并排序的思路</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> addToNew = right;<span class="comment">//新数组从尾往前填数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left]&gt;nums[right]*nums[right])&#123;</span><br><span class="line">                newNums[addToNew--] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newNums[addToNew--] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“移除”数组元素</title>
      <link href="/2021/10/15/%E2%80%9C%E7%A7%BB%E9%99%A4%E2%80%9D%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/"/>
      <url>/2021/10/15/%E2%80%9C%E7%A7%BB%E9%99%A4%E2%80%9D%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode–27-移除元素"><a href="#LeetCode–27-移除元素" class="headerlink" title="LeetCode–27.移除元素"></a>LeetCode–27.移除元素</h2><p><strong>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</strong></p><span id="more"></span><p><strong>说明:</strong><br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">removeElement</span>(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><br>示例2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 50</span><br><span class="line">0 &lt;= val &lt;= 100</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-element">链接：27.移动元素</a></p><h2 id="选哪种双指针？"><a href="#选哪种双指针？" class="headerlink" title="选哪种双指针？"></a>选哪种双指针？</h2><p>　　做这道题时我是第一次在LeetCode接触“双指针”，然而双指针其实有挺多种含义。就像这道题，快慢指针是经典解法，而首尾指针是优化解法。读完题目，我其实想到的是类似于首尾指针的解法，而不是经典的快慢指针——我认为首尾指针更符合删除元素的应用场景，而快慢指针可能只是通用思想。写完看题解，发现官方也是推荐首尾指针。当然，具体的原因是因为快慢指针在最坏情况下可能会进行不必要的元素覆盖操作，而首尾指针可以一步到位。</p><h2 id="题解–经典双指针-快慢指针"><a href="#题解–经典双指针-快慢指针" class="headerlink" title="题解–经典双指针(快慢指针)"></a>题解–经典双指针(快慢指针)</h2><h3 id="指针的作用是什么？"><a href="#指针的作用是什么？" class="headerlink" title="指针的作用是什么？"></a>指针的作用是什么？</h3><p>　　我特别思考了这两种指针(不是两个，即快慢指针和首尾指针)的作用。快指针在这道题里面相当于for循环经常定义的i，负责遍历数据，顺便看看当下遍历到的元素是不是val，再进行赋值等操作；满慢指针则是一个检查的角色，它的任务是确保当前指向的元素被非val的元素替换后才移动到下一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;<span class="comment">//慢指针，会停留在发现val的地方</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>;fastIndex&lt;nums.<span class="built_in">size</span>();fastIndex++)&#123;<span class="comment">//快指针只用用来遍历</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)&#123;<span class="comment">//快指针只会用不同于val的值覆盖前面的值</span></span><br><span class="line">                nums[slowIndex] = nums[fastIndex];<span class="comment">//只有正常情况时快慢指针才是同步的</span></span><br><span class="line">                slowIndex++;<span class="comment">//慢指针确保左边的每一个元素都符合要求后才继续前进</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解–双指针优化-首尾指针"><a href="#题解–双指针优化-首尾指针" class="headerlink" title="题解–双指针优化(首尾指针)"></a>题解–双指针优化(首尾指针)</h2><h3 id="首尾指针与快慢指针在作用上的区别是什么？"><a href="#首尾指针与快慢指针在作用上的区别是什么？" class="headerlink" title="首尾指针与快慢指针在作用上的区别是什么？"></a>首尾指针与快慢指针在作用上的区别是什么？</h3><ul><li>遍历：首尾指针均有双向遍历的责任，当重合时合计遍历一次即停止；而快慢指针几乎需要把同一个数组遍历两次。快指针从前往后扫描非val的值以备慢指针替换，<strong>但是慢指针遍历过的快指针其实也遍历过，</strong>而尾指针从后往前扫描非val的值以备首指针替换，扫描路径不重复。</li><li>元素顺序：快慢指针是“稳定”的算法，不会改变元素相对位置。但题目却提示我们元素顺序不要紧，这暗示了元素覆盖或许是一个优化的方向。因此首尾指针不在乎前后元素的顺序，尾指针只需要确保它遍历过的元素都被“用过并存在了前面的区间”，是否重复，无关紧要。</li><li>联系：首指针和慢指针的作用是一样的，都是为了确保它指向的元素一定符合题意才移动到下一个。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]!=val)&#123;<span class="comment">//正常的情况，left只需要向前进</span></span><br><span class="line">                left++;<span class="comment">//注意在判断一个正常的元素后，left再加1时已经是新数据的长度！！！</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//nums[left]==val</span></span><br><span class="line">                nums[left] = nums[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非递归版二分查找</title>
      <link href="/2021/10/14/%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/10/14/%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode–704-二分查找"><a href="#LeetCode–704-二分查找" class="headerlink" title="LeetCode–704.二分查找"></a>LeetCode–704.二分查找</h2><p><strong>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</strong></p><span id="more"></span><br>示例1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><br>示例 2:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你可以假设 nums 中的所有元素是不重复的。</span><br><span class="line">n 将在 [1, 10000]之间。</span><br><span class="line">nums 的每个元素都将在 [-9999, 9999]之间。</span><br></pre></td></tr></table></figure>[链接：704.二分查找](https://leetcode-cn.com/problems/binary-search)<h2 id="思考-amp-算法要点"><a href="#思考-amp-算法要点" class="headerlink" title="思考&amp;算法要点"></a>思考&amp;算法要点</h2><p>二分法确实比较简单，思想不用多说。但是落实到代码上，就可能会暴露一些问题：</p><ul><li><p>因为学数据结构接触到的是递归版本的，因此起初自然而然想到递归。写到一半才发现代码的参数根本不符合递归的写法hh，因为递归不需要对数组重复传参，且需要传递更新的区间，说明我还是生疏了。</p></li><li><p>循环结束的条件是对左右区间的判断</p></li><li><p>不过我还是意识到了区间在二分查找算法中的易错性，始终谨慎地处理边界，选择左右闭合。而且我模拟了这种分法在最后一步比较的情况：在左右指示变量重合时，被指向的元素还未与target比较，因此等号仍然成立。</p></li><li><p>如何计算mid的值？可能许多人会直接(left + right)/2，发现这两个变量可能会越界，这样就需要另外写一个代码块专门处理这个问题，虽然不难，但是会增加算法的时间复杂度(第5点会讲到)。但如果像是题解中“递增式”的计算，就从根本上避开了边界的判断，有点小妙哦…</p></li><li><p>关于算法运行的时间。可能是强迫症的原因，我知道最后一个else就是等于的情况，但我还是把等于的条件写了上去，结果LeetCode报超时==把这个条件去掉后，题解才过关了。深刻体会到大O不变、测试数据多的情况下，一些纯粹的条件判断还是挺占用时间的。虽然有点无语吧，但也正因为这样，类似于DFS的算法，剪枝优化才显得尤为重要。</p></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左闭右闭区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;  <span class="comment">//终止条件：==仍然有意义</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + (right - left) / <span class="number">2</span>);<span class="comment">//这种写法防止越界，不用另外处理边界问题</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt; nums[mid])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/20/hello-world/"/>
      <url>/2021/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="This-is-a-simple-test"><a href="#This-is-a-simple-test" class="headerlink" title="This is a simple test"></a>This is a simple test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;can you see me?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
