<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>螺旋矩阵II--严谨的边界处理</title>
      <link href="/2021/10/26/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II-%E4%B8%A5%E8%B0%A8%E7%9A%84%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/"/>
      <url>/2021/10/26/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II-%E4%B8%A5%E8%B0%A8%E7%9A%84%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-59-螺旋矩阵-II"><a href="#LeetCode-59-螺旋矩阵-II" class="headerlink" title="LeetCode-59. 螺旋矩阵 II"></a>LeetCode-59. 螺旋矩阵 II</h2><p><strong>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</strong></p><span id="more"></span><br>示例1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><br>示例2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>提示：1 <= n <= 20<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">链接：59. 螺旋矩阵 II</a></p><h2 id="怎么模拟？"><a href="#怎么模拟？" class="headerlink" title="怎么模拟？"></a>怎么模拟？</h2><p>　　这种题不考具体的算法，但是对代码的掌控能力要求很高。这道题模拟的本质其实是<strong>对数组下标的计算和控制</strong>，但刚开始我还是想着四个区域，每个区域一次性填完再轮下一个，但是发现不好操作，因为这种填数比较适合<strong>区域内的数字相同或有某种比较直接的数学规律的情况</strong>。而且既然决定是模拟，就要按照<strong>题意说的螺旋顺序</strong>，而不是线性顺序。<br>　　控制下标的方法很多，例如用direction数组，不过这里我的思路是：分区模拟，从外往内一圈一圈地填数，分别以主对角线和副对角线作为四个区域的分界线。主对角线条件是row==col，副对角线条件是row+col=n-1，只需要分清楚每个区域是大于还是小于对角线就可以了。<br>　　另外在写边界判定时还需要全程注意：每个区域都遵循左闭右开原则，否则思路会很乱。最后，如果是奇数圈，中间的数字需要单独填。每次while循环中，每个小for循环负责填单个区域的<strong>一行数</strong>。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">matrix</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//定义二维数组</span></span><br><span class="line">        <span class="keyword">int</span> cycle = n/<span class="number">2</span>;<span class="comment">//要螺旋多少圈，奇数圈最中间的元素要另外考虑</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cycle--)&#123;</span><br><span class="line">            <span class="comment">//上：从左往右填数</span></span><br><span class="line">            <span class="keyword">for</span>(;row+col&lt;n<span class="number">-1</span>;col++)&#123;</span><br><span class="line">                matrix[row][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右：从上往下填数</span></span><br><span class="line">            <span class="keyword">for</span>(;row&lt;col;row++)&#123;</span><br><span class="line">                matrix[row][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下：从右往左填数</span></span><br><span class="line">            <span class="keyword">for</span>(;row+col&gt;n<span class="number">-1</span>;col--)&#123;</span><br><span class="line">                matrix[row][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左：从下往上填数</span></span><br><span class="line">            <span class="keyword">for</span>(;row&gt;col;row--)&#123;</span><br><span class="line">                matrix[row][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一圈从主对角线的斜右下元素开始</span></span><br><span class="line">            row++;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果n是奇数，最中间的数字没有填充</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            matrix[n/<span class="number">2</span>][n/<span class="number">2</span>]=n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组--滑动窗口&amp;前缀和</title>
      <link href="/2021/10/17/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2021/10/17/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode-209.长度最小的子数组"></a>LeetCode-209.长度最小的子数组</h2><p><strong>给定一个含有 n 个正整数的数组和一个正整数 target 。</strong><br><strong>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</strong></p><span id="more"></span><br>示例 1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><br>示例 2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><br>示例 3：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= target &lt;= 109</span><br><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">1 &lt;= nums[i] &lt;= 105</span><br></pre></td></tr></table></figure>进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum">链接：209.长度最小的子数组</a></p><h2 id="题解–暴力遍历连续区间"><a href="#题解–暴力遍历连续区间" class="headerlink" title="题解–暴力遍历连续区间"></a>题解–暴力遍历连续区间</h2><p>　　由于以前没有接触过滑动窗口的具体思想，虽然沿袭了“双指针”的做法，但仍然属于暴力遍历连续区间=.=即每次都要从新的起点开始找最小区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next,sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> begin=<span class="number">0</span>;begin&lt;nums.<span class="built_in">size</span>();begin++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            next = begin;<span class="comment">//起点不同，所以每次都要重新开始找连续子区间</span></span><br><span class="line">            <span class="keyword">while</span>(next &lt; nums.<span class="built_in">size</span>())&#123;<span class="comment">//不能越界</span></span><br><span class="line">                sum += nums[next++];<span class="comment">//一定要注意循环结束时next自增多了一次</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((next - begin) &lt; minLength)&#123;</span><br><span class="line">                        minLength = next - begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不要遗漏找不到连续子序列的情况</span></span><br><span class="line">        <span class="keyword">if</span>(minLength &gt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口妙在哪？"><a href="#滑动窗口妙在哪？" class="headerlink" title="滑动窗口妙在哪？"></a>滑动窗口妙在哪？</h2><p>　　滑动窗口的左右两个指针始终都在<strong>为了尽量保持求和满足条件</strong>而动态调整，每当左边淘汰旧元素，求和减少，而右边新增元素至满足条件时，新的最小区间又形成了，以此类推，整个过程如同有一个动态窗口在数组从左往右扫描过一样生动形象。<strong>因此，如果说滑动窗口右指针是在努力满足求和条件，那么左指针就是在满足条件后尝试逐步减少元素个数，</strong>整趟下来就能找出最小值。<br>　　而暴力找区间呢？左指针有且只有逐个遍历元素、重新定义左边界的作用，而且右指针每次都需要重新回到左指针的位置，重新定义尝试区间长度，多出不少迭代次数。<br>　　由此可见，<strong>虽然滑动窗口在本质上也是双指针实现，但在不同的算法操作下有截然不同的效果。</strong></p><h2 id="题解–滑动窗口"><a href="#题解–滑动窗口" class="headerlink" title="题解–滑动窗口"></a>题解–滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//还是双指针，其中一个负责同步遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                minLength = (right-left+<span class="number">1</span>)&lt;minLength?(right-left+<span class="number">1</span>):minLength;<span class="comment">//在left自增前赋值</span></span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength==INT32_MAX?<span class="number">0</span>:minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="以空间换时间–用前缀和对付“连续子区间的和”"><a href="#以空间换时间–用前缀和对付“连续子区间的和”" class="headerlink" title="以空间换时间–用前缀和对付“连续子区间的和”"></a>以空间换时间–用前缀和对付“连续子区间的和”</h2><p>　　因为前段时间有在备战CCF，其中第二道题的套路之一就是前缀和思想，因此当我看到这道题要求连续元素的和时，很自然地想到了用前缀和。但是我当时还不懂滑动窗口，停留在暴力解的思路，没搞懂用前缀和相减求子区间的和与累计相加的区别，二者在基本执行语句上基本一致=.=还是当我写完暴力去翻官方题解时，才知道大牛都是脑洞大开。<br>　　其实只要把sums[bound]−sums[i−1]≥preSum这个不等式做个移项就好理解多了，这样不等式右边在每次循环中是常量，<strong>对原数组的操作转化为了对前缀和数组(而且有有序递增数组)的折半查找。</strong>时间复杂度之所以比暴力法小，从基本语句执行的角度说是因为折半查找的平均次数要少于逐次循环累计的次数。期间用到了二分查找的变形，在我前些天的博客有补充。<br>　　这虽然不是最优的方法，但我觉得评论区说的有理。收获了一个思考问题的角度，也收获了前缀和在不同场景下的应用，加强算法迁移能力。</p><h2 id="题解–前缀和搭配折半查找"><a href="#题解–前缀和搭配折半查找" class="headerlink" title="题解–前缀和搭配折半查找"></a>题解–前缀和搭配折半查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sums</span><span class="params">(length+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//i-1不能为0</span></span><br><span class="line">        <span class="comment">//计算前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类似暴力解的思路寻找连续子区间，只不过优化了寻找到右边界的过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> preSum = sums[i<span class="number">-1</span>] + target;<span class="comment">//preSum表示应该期望得到的前缀和</span></span><br><span class="line">            <span class="keyword">auto</span> bound = <span class="built_in">lower_bound</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), preSum);<span class="comment">//注意类型转换</span></span><br><span class="line">            <span class="keyword">if</span>(bound != sums.<span class="built_in">end</span>())&#123;</span><br><span class="line">                minLength = <span class="built_in">min</span>(minLength, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((bound-sums.<span class="built_in">begin</span>()) - (i<span class="number">-1</span>))); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength==INT_MAX?<span class="number">0</span>:minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方--首尾双指针+归并思想</title>
      <link href="/2021/10/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-%E9%A6%96%E5%B0%BE%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BD%92%E5%B9%B6%E6%80%9D%E6%83%B3/"/>
      <url>/2021/10/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-%E9%A6%96%E5%B0%BE%E5%8F%8C%E6%8C%87%E9%92%88-%E5%BD%92%E5%B9%B6%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode-977.有序数组的平方"></a>LeetCode-977.有序数组的平方</h2><p><strong>给你一个按非递减顺序 排序的整数数组 nums，返回每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</strong></p><span id="more"></span><br>示例 1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><br>示例 2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 已按 非递减顺序 排序</span><br></pre></td></tr></table></figure>进阶：请你设计时间复杂度为 O(n) 的算法解决本问题<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">链接：977.有序数组的平方</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>　　题目既然给了有序的条件就要利用好，平方只是一个干扰。平方后数组递减后递增，呈“V”字形，使用首尾双指针比较元素后填数即可。本质上是两个有序子序列的重新排序，属于<strong>归并思想</strong>。官方题解的第二种方法还需要找出中间的分界值，感觉没这必要，从中间往两边扩散很容易数组越界==　　</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开辟新数组存储结果</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; newNums = <span class="built_in">vector</span>(nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//对两个递减和递增子序列排序，本质上是归并排序的思路</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> addToNew = right;<span class="comment">//新数组从尾往前填数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]*nums[left]&gt;nums[right]*nums[right])&#123;</span><br><span class="line">                newNums[addToNew--] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newNums[addToNew--] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“移除”数组元素</title>
      <link href="/2021/10/15/%E2%80%9C%E7%A7%BB%E9%99%A4%E2%80%9D%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/"/>
      <url>/2021/10/15/%E2%80%9C%E7%A7%BB%E9%99%A4%E2%80%9D%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode–27-移除元素"><a href="#LeetCode–27-移除元素" class="headerlink" title="LeetCode–27.移除元素"></a>LeetCode–27.移除元素</h2><p><strong>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</strong></p><span id="more"></span><p><strong>说明:</strong><br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">removeElement</span>(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><br>示例2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 50</span><br><span class="line">0 &lt;= val &lt;= 100</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-element">链接：27.移动元素</a></p><h2 id="选哪种双指针？"><a href="#选哪种双指针？" class="headerlink" title="选哪种双指针？"></a>选哪种双指针？</h2><p>　　做这道题时我是第一次在LeetCode接触“双指针”，然而双指针其实有挺多种含义。就像这道题，快慢指针是经典解法，而首尾指针是优化解法。读完题目，我其实想到的是类似于首尾指针的解法，而不是经典的快慢指针——我认为首尾指针更符合删除元素的应用场景，而快慢指针可能只是通用思想。写完看题解，发现官方也是推荐首尾指针。当然，具体的原因是因为快慢指针在最坏情况下可能会进行不必要的元素覆盖操作，而首尾指针可以一步到位。</p><h2 id="题解–经典双指针-快慢指针"><a href="#题解–经典双指针-快慢指针" class="headerlink" title="题解–经典双指针(快慢指针)"></a>题解–经典双指针(快慢指针)</h2><h3 id="指针的作用是什么？"><a href="#指针的作用是什么？" class="headerlink" title="指针的作用是什么？"></a>指针的作用是什么？</h3><p>　　我特别思考了这两种指针(不是两个，即快慢指针和首尾指针)的作用。快指针在这道题里面相当于for循环经常定义的i，负责遍历数据，顺便看看当下遍历到的元素是不是val，再进行赋值等操作；满慢指针则是一个检查的角色，它的任务是确保当前指向的元素被非val的元素替换后才移动到下一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;<span class="comment">//慢指针，会停留在发现val的地方</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>;fastIndex&lt;nums.<span class="built_in">size</span>();fastIndex++)&#123;<span class="comment">//快指针只用用来遍历</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)&#123;<span class="comment">//快指针只会用不同于val的值覆盖前面的值</span></span><br><span class="line">                nums[slowIndex] = nums[fastIndex];<span class="comment">//只有正常情况时快慢指针才是同步的</span></span><br><span class="line">                slowIndex++;<span class="comment">//慢指针确保左边的每一个元素都符合要求后才继续前进</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解–双指针优化-首尾指针"><a href="#题解–双指针优化-首尾指针" class="headerlink" title="题解–双指针优化(首尾指针)"></a>题解–双指针优化(首尾指针)</h2><h3 id="首尾指针与快慢指针在作用上的区别是什么？"><a href="#首尾指针与快慢指针在作用上的区别是什么？" class="headerlink" title="首尾指针与快慢指针在作用上的区别是什么？"></a>首尾指针与快慢指针在作用上的区别是什么？</h3><ul><li>遍历：首尾指针均有双向遍历的责任，当重合时合计遍历一次即停止；而快慢指针几乎需要把同一个数组遍历两次。快指针从前往后扫描非val的值以备慢指针替换，<strong>但是慢指针遍历过的快指针其实也遍历过，</strong>而尾指针从后往前扫描非val的值以备首指针替换，扫描路径不重复。</li><li>元素顺序：快慢指针是“稳定”的算法，不会改变元素相对位置。但题目却提示我们元素顺序不要紧，这暗示了元素覆盖或许是一个优化的方向。因此首尾指针不在乎前后元素的顺序，尾指针只需要确保它遍历过的元素都被“用过并存在了前面的区间”，是否重复，无关紧要。</li><li>联系：首指针和慢指针的作用是一样的，都是为了确保它指向的元素一定符合题意才移动到下一个。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]!=val)&#123;<span class="comment">//正常的情况，left只需要向前进</span></span><br><span class="line">                left++;<span class="comment">//注意在判断一个正常的元素后，left再加1时已经是新数据的长度！！！</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//nums[left]==val</span></span><br><span class="line">                nums[left] = nums[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非递归版二分查找--子区间的定义是循环不变量!!</title>
      <link href="/2021/10/14/%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/10/14/%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode–704-二分查找"><a href="#LeetCode–704-二分查找" class="headerlink" title="LeetCode–704.二分查找"></a>LeetCode–704.二分查找</h2><p><strong>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</strong></p><span id="more"></span><br>示例1：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><br>示例 2:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><br>提示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你可以假设 nums 中的所有元素是不重复的。</span><br><span class="line">n 将在 [1, 10000]之间。</span><br><span class="line">nums 的每个元素都将在 [-9999, 9999]之间。</span><br></pre></td></tr></table></figure>[链接：704.二分查找](https://leetcode-cn.com/problems/binary-search)<h2 id="思考-amp-算法要点"><a href="#思考-amp-算法要点" class="headerlink" title="思考&amp;算法要点"></a>思考&amp;算法要点</h2><p>二分法确实比较简单，思想不用多说。但是落实到代码上，就可能会暴露一些问题：</p><ul><li><p>因为学数据结构接触到的是递归版本的，因此起初自然而然想到递归。写到一半才发现代码的参数根本不符合递归的写法hh，因为递归不需要对数组重复传参，且需要传递更新的区间，说明我还是生疏了。</p></li><li><p>循环结束的条件是对左右区间的判断</p></li><li><p>不过我还是意识到了区间在二分查找算法中的易错性，始终谨慎地处理边界，选择左右闭合。而且我模拟了这种分法在最后一步比较的情况：在左右指示变量重合时，被指向的元素还未与target比较，因此等号仍然成立。</p></li><li><p>如何计算mid的值？可能许多人会直接(left + right)/2，发现这两个变量可能会越界，这样就需要另外写一个代码块专门处理这个问题，虽然不难，但是会增加算法的时间复杂度(第5点会讲到)。但如果像是题解中“递增式”的计算，就从根本上避开了边界的判断，有点小妙哦…</p></li><li><p>关于算法运行的时间。可能是强迫症的原因，我知道最后一个else就是等于的情况，但我还是把等于的条件写了上去，结果LeetCode报超时==把这个条件去掉后，题解才过关了。深刻体会到大O不变、测试数据多的情况下，一些纯粹的条件判断还是挺占用时间的。虽然有点无语吧，但也正因为这样，类似于DFS的算法，剪枝优化才显得尤为重要。</p></li></ul><h2 id="题解–左右闭合区间"><a href="#题解–左右闭合区间" class="headerlink" title="题解–左右闭合区间"></a>题解–左右闭合区间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左闭右闭区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;  <span class="comment">//终止条件：==仍然有意义</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + (right - left) / <span class="number">2</span>);<span class="comment">//这种写法防止越界，不用另外处理边界问题</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt; nums[mid])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="左闭右开区间–循环中坚持不变量"><a href="#左闭右开区间–循环中坚持不变量" class="headerlink" title="左闭右开区间–循环中坚持不变量"></a>左闭右开区间–循环中坚持不变量</h2><p>　　上面的解法其实相对左闭右开区间没有这么容易犯错。但是几天后当我看到<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/">209.长度最小的子数组的题解</a>时，发现官方顺带实现了含有重复元素的折半查找算法，用的是左闭右开区间——我发现平时更多时候用的是这种区间定义，于是还是决定熟悉一下。<br>　　其实二者要变动的不多。二者在上一趟的区间中，mid的值已经被比较过了，下一趟都不会再比较。左右闭合区间的两个指针都是在mid的两边重新落定位置，而左闭右开区间的右指针则比较特殊，在每次划分区间时都必须指向右区间的后一个位置(即不会另外+1)，左指针的规则不变，源码如下。</p><h2 id="题解–左闭右开区间"><a href="#题解–左闭右开区间" class="headerlink" title="题解–左闭右开区间"></a>题解–左闭右开区间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =nums.<span class="built_in">size</span>();<span class="comment">//改动1：right初始化为开区间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;  <span class="comment">//改动2：终止条件：left == right 没有意义</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + (right - left) / <span class="number">2</span>);<span class="comment">//防止越界</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid;<span class="comment">//改动3：变成开区间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt; nums[mid])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拓展：找到首个比目标元素大的折半查找"><a href="#拓展：找到首个比目标元素大的折半查找" class="headerlink" title="拓展：找到首个比目标元素大的折半查找"></a>拓展：找到首个比目标元素大的折半查找</h2><h2 id="题解–二分查找比某个元素大的第一个位置"><a href="#题解–二分查找比某个元素大的第一个位置" class="headerlink" title="题解–二分查找比某个元素大的第一个位置"></a>题解–二分查找比某个元素大的第一个位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/20/hello-world/"/>
      <url>/2021/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="This-is-a-simple-test"><a href="#This-is-a-simple-test" class="headerlink" title="This is a simple test"></a>This is a simple test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;can you see me?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
